#!/usr/bin/env bash

# MCP Server Setup Script for Claude Code
# This script manages MCP (Model Context Protocol) servers for use with Claude
# Run this in each project to ensure MCP servers are properly configured

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

# Get server name by key
get_server_name() {
    case $1 in
        serena) echo "Serena (Code Development)" ;;
        context7) echo "Context7 (Documentation)" ;;
        zen) echo "Zen (AI Assistant Tools)" ;;
        tavily) echo "Tavily (Web Search)" ;;
        browser) echo "Browser Tools" ;;
        playwright) echo "Playwright" ;;
        database) echo "Database MCP (SQL Access)" ;;
        vibe-eyes) echo "Vibe Eyes (Browser Canvas Visualization)" ;;
        *) echo "" ;;
    esac
}

# Get server command by key
get_server_command() {
    case $1 in
        serena) echo 'claude mcp add serena -- uvx --from git+https://github.com/oraios/serena serena-mcp-server --context ide-assistant --project "$PROJECT_DIR"' ;;
        context7) echo 'claude mcp add context7 -- npx -y @upstash/context7-mcp' ;;
        zen) echo 'claude mcp add zen -- sh -c "exec $(which uvx || echo uvx) --from git+https://github.com/BeehiveInnovations/zen-mcp-server.git zen-mcp-server"' ;;
        tavily) echo 'claude mcp add tavily -- sh -c "exec npx -y tavily-mcp@latest"' ;;
        browser) echo 'claude mcp add browsermcp -- sh -c "exec npx @browsermcp/mcp@latest"' ;;
        playwright) echo 'claude mcp add playwright -- sh -c "exec npx @playwright/mcp@latest"' ;;
        database) echo 'SPECIAL_HANDLING' ;; # Database needs custom handling for DB_CONFIGS
        vibe-eyes) echo 'SPECIAL_HANDLING' ;; # Vibe-eyes needs special setup
        *) echo "" ;;
    esac
}

# Get all server keys
get_all_server_keys() {
    echo "serena context7 zen tavily browser playwright database vibe-eyes"
}

# Check for required environment variables
check_environment() {
    local missing_vars=()
    local required_vars=(
        "OPENAI_API_KEY"
        "ANTHROPIC_API_KEY"
        "GOOGLE_CLOUD_PROJECT"
        "TAVILY_API_KEY"
    )
    
    print_status "Checking required environment variables..."
    
    for var in "${required_vars[@]}"; do
        if [ -z "${!var}" ]; then
            missing_vars+=("$var")
        else
            echo "  âœ“ $var is set"
        fi
    done
    
    if [ ${#missing_vars[@]} -ne 0 ]; then
        print_error "Missing required environment variables:"
        for var in "${missing_vars[@]}"; do
            echo "  - $var"
        done
        echo ""
        echo "Please set these environment variables before continuing."
        echo "You can add them to your shell profile or .env file."
        exit 1
    fi
    
    print_status "All required environment variables are set âœ“"
}

# Check for required tools
check_requirements() {
    local missing_tools=()
    
    print_status "Checking required tools..."
    
    # Check for uv/uvx
    if ! command -v uvx &> /dev/null && ! command -v uv &> /dev/null; then
        missing_tools+=("uv/uvx")
    else
        echo "  âœ“ uv/uvx found"
    fi
    
    # Check for npm/npx
    if ! command -v npx &> /dev/null; then
        missing_tools+=("npx")
    else
        echo "  âœ“ npx found"
    fi
    
    # Check for claude CLI
    if ! command -v claude &> /dev/null; then
        missing_tools+=("claude")
    else
        echo "  âœ“ claude CLI found"
    fi
    
    if [ ${#missing_tools[@]} -ne 0 ]; then
        print_error "Missing required tools: ${missing_tools[*]}"
        echo ""
        echo "Installation instructions:"
        echo "  - uv/uvx: curl -LsSf https://astral.sh/uv/install.sh | sh"
        echo "  - npx: Install Node.js (https://nodejs.org/)"
        echo "  - claude: See https://docs.anthropic.com/en/docs/claude-code"
        exit 1
    fi
    
    print_status "All required tools are installed âœ“"
}

# Parse a database URL and extract components
parse_database_url() {
    local url="$1"
    
    # Try to use Python if available for robust parsing
    if command -v python3 &> /dev/null; then
        python3 -c "
import urllib.parse
import json
import sys

try:
    url = '$url'
    parsed = urllib.parse.urlparse(url)
    
    # Determine default port based on scheme
    default_port = 5432 if parsed.scheme in ['postgres', 'postgresql'] else 3306
    
    # Extract components
    result = {
        'scheme': parsed.scheme,
        'user': parsed.username or '',
        'password': parsed.password or '',
        'host': parsed.hostname or 'localhost',
        'port': parsed.port or default_port,
        'dbname': parsed.path.lstrip('/') if parsed.path else ''
    }
    
    # Output as key=value pairs for bash
    for k, v in result.items():
        print(f'{k}={v}')
except Exception as e:
    sys.exit(1)
"
    else
        # Fallback to bash parsing
        # Format: scheme://user:pass@host:port/dbname
        local regex='^(postgres|postgresql|mysql|mariadb)://([^:]+):([^@]+)@([^:]+):([0-9]+)/(.+)$'
        
        if [[ $url =~ $regex ]]; then
            echo "scheme=${BASH_REMATCH[1]}"
            echo "user=${BASH_REMATCH[2]}"
            echo "password=${BASH_REMATCH[3]}"
            echo "host=${BASH_REMATCH[4]}"
            echo "port=${BASH_REMATCH[5]}"
            echo "dbname=${BASH_REMATCH[6]}"
        else
            # Try without port
            regex='^(postgres|postgresql|mysql|mariadb)://([^:]+):([^@]+)@([^/]+)/(.+)$'
            if [[ $url =~ $regex ]]; then
                local scheme="${BASH_REMATCH[1]}"
                local default_port=5432
                if [[ "$scheme" == "mysql" ]] || [[ "$scheme" == "mariadb" ]]; then
                    default_port=3306
                fi
                echo "scheme=$scheme"
                echo "user=${BASH_REMATCH[2]}"
                echo "password=${BASH_REMATCH[3]}"
                echo "host=${BASH_REMATCH[4]}"
                echo "port=$default_port"
                echo "dbname=${BASH_REMATCH[5]}"
            else
                return 1
            fi
        fi
    fi
}

# Generate DB_CONFIGS JSON for database-mcp
generate_db_configs() {
    local urls=("$@")
    local json_configs=()
    
    for url in "${urls[@]}"; do
        # Parse the URL
        local parsed=$(parse_database_url "$url")
        if [ $? -ne 0 ]; then
            print_error "Failed to parse database URL: $url"
            return 1
        fi
        
        # Extract values
        eval "$parsed"
        
        # Determine db_type based on scheme
        local db_type=""
        case "$scheme" in
            postgres|postgresql)
                db_type="pg"
                ;;
            mysql|mariadb)
                db_type="mysql"
                ;;
            *)
                print_error "Unsupported database type: $scheme"
                return 1
                ;;
        esac
        
        # Generate description (capitalize first letter)
        local scheme_cap=""
        case "$scheme" in
            postgres|postgresql)
                scheme_cap="PostgreSQL"
                ;;
            mysql|mariadb)
                scheme_cap="MySQL"
                ;;
        esac
        local description="$scheme_cap Database for $dbname"
        
        # Build JSON config for this database (minified)
        local config=$(printf '{"id":"%s","db_type":"%s","configuration":{"host":"%s","port":%d,"user":"%s","password":"%s","dbname":"%s"},"description":"%s"}' \
            "$dbname" "$db_type" "$host" "$port" "$user" "$password" "$dbname" "$description")
        
        json_configs+=("$config")
    done
    
    # Join configs into array
    local joined=""
    for ((i=0; i<${#json_configs[@]}; i++)); do
        if [ $i -gt 0 ]; then
            joined+=","
        fi
        joined+="${json_configs[$i]}"
    done
    
    # Output as single-line JSON array
    echo "[$joined]"
}

# Collect database URLs interactively
collect_database_urls() {
    local urls=()
    
    echo ""
    echo "Enter database URLs (one per line)."
    echo "Supported formats:"
    echo "  postgres://user:password@host:port/dbname"
    echo "  mysql://user:password@host:port/dbname"
    echo "Press Enter with empty line when done."
    echo ""
    
    while true; do
        read -p "Database URL (or press Enter to finish): " url
        if [ -z "$url" ]; then
            break
        fi
        
        # Validate URL format
        if parse_database_url "$url" > /dev/null 2>&1; then
            urls+=("$url")
            print_status "Added database URL for parsing"
        else
            print_error "Invalid database URL format. Please try again."
            print_error "Supported schemes: postgres, postgresql, mysql, mariadb"
        fi
    done
    
    if [ ${#urls[@]} -eq 0 ]; then
        return 1
    fi
    
    # Generate and export DB_CONFIGS
    local db_configs=$(generate_db_configs "${urls[@]}")
    if [ $? -eq 0 ]; then
        export DB_CONFIGS="$db_configs"
        return 0
    else
        return 1
    fi
}

# Function to install a single MCP server
install_server() {
    local server_key=$1
    local server_name=$(get_server_name "$server_key")
    local server_command=$(get_server_command "$server_key")
    
    if [ -z "$server_name" ]; then
        print_error "Unknown server: $server_key"
        return 1
    fi
    
    print_status "Installing $server_name..."
    
    # Special handling for vibe-eyes server
    if [ "$server_key" = "vibe-eyes" ]; then
        print_warning "Vibe-eyes requires special setup due to console output issues"
        echo ""
        echo "Two options for installing vibe-eyes:"
        echo ""
        echo "Option 1: Clone and run locally (recommended):"
        echo "  git clone https://github.com/monteslu/vibe-eyes.git"
        echo "  cd vibe-eyes"
        echo "  npm install"
        echo "  # Create a wrapper script to suppress console output"
        echo "  cat > run-silent.mjs << 'EOF'"
        echo "console.log = console.error = () => {};"
        echo "import('./mcp.js');"
        echo "EOF"
        echo "  # Then add to Claude:"
        echo "  claude mcp add vibe-eyes -- node \$(pwd)/run-silent.mjs"
        echo ""
        echo "Option 2: Create a local wrapper (automated):"
        
        if [ "$NON_INTERACTIVE" = true ]; then
            print_error "Vibe-eyes requires manual setup in non-interactive mode"
            return 1
        fi
        
        read -p "Would you like to create a local wrapper? (y/N): " create_wrapper
        if [[ "$create_wrapper" =~ ^[Yy]$ ]]; then
            local wrapper_dir="$HOME/.claude/mcp-wrappers"
            mkdir -p "$wrapper_dir"
            
            cat > "$wrapper_dir/vibe-eyes-wrapper.mjs" << 'EOF'
// Wrapper to suppress console output from vibe-eyes
const originalLog = console.log;
const originalError = console.error;
console.log = console.error = () => {};

// Import and run the MCP server
import '@monteslu/vibe-eyes/mcp.js';

// Note: We can't easily intercept StdioServerTransport with ES modules
// but the console suppression should handle most issues
EOF
            
            # Install vibe-eyes locally in the wrapper directory
            print_status "Installing @monteslu/vibe-eyes..."
            (cd "$wrapper_dir" && npm install @monteslu/vibe-eyes @modelcontextprotocol/sdk)
            
            # Add to Claude
            if claude mcp add vibe-eyes -- node "$wrapper_dir/vibe-eyes-wrapper.mjs"; then
                print_status "âœ“ Vibe-eyes installed with wrapper"
                echo ""
                print_info "The vibe-eyes server will run on port 8869"
                print_info "Make sure your browser client connects to ws://localhost:8869"
                return 0
            else
                print_error "Failed to add vibe-eyes to Claude"
                return 1
            fi
        else
            print_info "Skipping vibe-eyes installation"
            return 1
        fi
    fi
    
    # Special handling for database server
    if [ "$server_key" = "database" ]; then
        # Check for MySQL client libraries (required even for PostgreSQL)
        if ! command -v mysql_config &> /dev/null && ! command -v mariadb_config &> /dev/null; then
            print_warning "MySQL client libraries are required for database-mcp (even for PostgreSQL databases)"
            echo "Install with one of:"
            echo "  macOS: brew install mysql-client"
            echo "  Ubuntu/Debian: sudo apt-get install libmysqlclient-dev"
            echo "  RHEL/CentOS: sudo yum install mysql-devel"
            echo ""
            
            if [ "$NON_INTERACTIVE" = true ]; then
                print_error "Cannot proceed without MySQL client libraries"
                return 1
            else
                read -p "Do you want to continue anyway? (y/N): " continue_anyway
                if [[ ! "$continue_anyway" =~ ^[Yy]$ ]]; then
                    return 1
                fi
            fi
        fi
        
        local urls=()
        
        # Check if DB_CONFIGS is already set
        if [ -z "$DB_CONFIGS" ]; then
            if [ "$NON_INTERACTIVE" = true ]; then
                if [ -z "$DATABASE_URLS" ]; then
                    print_error "Database URLs required. Use --database-urls or set DB_CONFIGS environment variable"
                    return 1
                fi
                # Parse DATABASE_URLS (semicolon-separated for safety)
                IFS=';' read -ra urls <<< "$DATABASE_URLS"
                local db_configs=$(generate_db_configs "${urls[@]}")
                if [ $? -ne 0 ]; then
                    return 1
                fi
                export DB_CONFIGS="$db_configs"
            else
                # Interactive mode: collect URLs
                if ! collect_database_urls; then
                    print_error "No database URLs provided"
                    return 1
                fi
                # Count URLs from DB_CONFIGS (rough estimate)
                urls=($(echo "$DB_CONFIGS" | grep -o '"id"' | wc -l))
            fi
        else
            # DB_CONFIGS already set, estimate count
            urls=($(echo "$DB_CONFIGS" | grep -o '"id"' | wc -l))
        fi
        
        # Install with DB_CONFIGS
        # Need to properly escape the JSON for the command line
        local escaped_configs="${DB_CONFIGS//\"/\\\"}"
        
        local cmd="claude mcp add database -e \"DB_CONFIGS=$escaped_configs\" -- database-mcp"
        
        # Redirect the command output to capture it
        local install_output
        if install_output=$(eval "$cmd" 2>&1); then
            # Show only the essential part of the output
            echo "$install_output" | grep -E "^Added" || echo "Database MCP server added to Claude configuration"
            print_status "âœ“ $server_name installed successfully"
            
            # Show configured databases
            local db_count=$(echo "$DB_CONFIGS" | grep -o '"id"' | wc -l | tr -d ' ')
            if [ "$db_count" -gt 0 ]; then
                echo ""
                print_info "Configured $db_count database connection(s):"
                # Extract and display database IDs
                echo "$DB_CONFIGS" | grep -o '"id": *"[^"]*"' | sed 's/"id": *"//; s/"$//' | while read -r db_id; do
                    echo "  â€¢ $db_id"
                done
            fi
            return 0
        else
            print_error "âœ— Failed to install $server_name"
            print_error "Error output:"
            echo "$install_output" >&2
            print_error "Command that failed: $cmd"
            return 1
        fi
    fi
    
    # Regular server installation
    local install_output
    if install_output=$(eval "$server_command" 2>&1); then
        # Show the Added line if present
        echo "$install_output" | grep -E "^Added" || true
        print_status "âœ“ $server_name installed successfully"
        
        # For Serena, provide instructions about project name configuration
        if [ "$server_key" = "serena" ]; then
            local default_name="$(basename "$PROJECT_DIR")"
            local project_name=""
            
            if [ "$NON_INTERACTIVE" = true ]; then
                # Non-interactive mode: use provided name or default
                if [ -n "$SERENA_PROJECT_NAME" ]; then
                    project_name="$SERENA_PROJECT_NAME"
                else
                    project_name="$default_name"
                fi
            else
                # Interactive mode: prompt for desired name
                echo ""
                echo "Serena will create .serena/project.yml when first connected in Claude Code."
                echo "The default project name will be: '$default_name'"
                echo "For monorepos or multiple checkouts, you should use a unique name."
                echo ""
                
                read -p "What project name would you like to use? (default: $default_name): " project_name
                project_name="${project_name:-$default_name}"
            fi
            
            # Store the project name for later reference
            export SERENA_CHOSEN_NAME="$project_name"
            
            if [ "$project_name" != "$default_name" ]; then
                echo ""
                print_info "IMPORTANT: After first connecting to Serena in Claude Code:"
                print_info "1. Edit $PROJECT_DIR/.serena/project.yml"
                print_info "2. Change 'project_name' to: $project_name"
                echo ""
            fi
        fi
        
        return 0
    else
        print_error "âœ— Failed to install $server_name"
        print_error "Error output:"
        echo "$install_output" >&2
        return 1
    fi
}

# Function to uninstall a single MCP server
uninstall_server() {
    local server_key=$1
    local server_name=$(get_server_name "$server_key")
    
    if [ -z "$server_name" ]; then
        print_error "Unknown server: $server_key"
        return 1
    fi
    
    print_status "Uninstalling $server_name..."
    
    # Map server keys to claude mcp names
    local mcp_name=$server_key
    if [ "$server_key" = "browser" ]; then
        mcp_name="browsermcp"
    elif [ "$server_key" = "database" ]; then
        mcp_name="database"
    elif [ "$server_key" = "vibe-eyes" ]; then
        mcp_name="vibe-eyes"
    fi
    
    if claude mcp remove "$mcp_name"; then
        print_status "âœ“ $server_name uninstalled successfully"
        return 0
    else
        print_error "âœ— Failed to uninstall $server_name"
        return 1
    fi
}

# Install command handler
handle_install() {
    shift # Remove 'install' from arguments
    local project_dir=""
    local servers_to_install=()
    local servers_to_exclude=()
    local install_all=false
    export SERENA_PROJECT_NAME=""
    export NON_INTERACTIVE=false
    export DATABASE_URLS=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --all)
                install_all=true
                shift
                ;;
            --exclude)
                if [ -z "$2" ]; then
                    print_error "Option --exclude requires a value"
                    exit 1
                fi
                # Split comma-separated values
                IFS=',' read -ra exclude_list <<< "$2"
                servers_to_exclude+=("${exclude_list[@]}")
                shift 2
                ;;
            --profile)
                if [ -z "$2" ]; then
                    print_error "Option --profile requires a value"
                    exit 1
                fi
                case $2 in
                    frontend)
                        install_all=true
                        servers_to_exclude+=("database")
                        ;;
                    backend)
                        install_all=true
                        servers_to_exclude+=("browser" "playwright")
                        ;;
                    api)
                        install_all=true
                        servers_to_exclude+=("browser" "playwright")
                        ;;
                    fullstack)
                        install_all=true
                        ;;
                    *)
                        print_error "Unknown profile: $2"
                        echo "Available profiles: frontend, backend, api, fullstack"
                        exit 1
                        ;;
                esac
                shift 2
                ;;
            --non-interactive|-n)
                NON_INTERACTIVE=true
                shift
                ;;
            --serena-project-name)
                if [ -z "$2" ]; then
                    print_error "Option --serena-project-name requires a value"
                    exit 1
                fi
                SERENA_PROJECT_NAME="$2"
                shift 2
                ;;
            --database-urls)
                if [ -z "$2" ]; then
                    print_error "Option --database-urls requires a value"
                    exit 1
                fi
                DATABASE_URLS="$2"
                shift 2
                ;;
            -*)
                print_error "Unknown option: $1"
                exit 1
                ;;
            *)
                # If no servers specified yet and this looks like a path, it's the project directory
                if [ ${#servers_to_install[@]} -eq 0 ] && [ -d "$1" ]; then
                    project_dir="$1"
                else
                    servers_to_install+=("$1")
                fi
                shift
                ;;
        esac
    done
    
    # Set project directory
    project_dir="${project_dir:-$(pwd)}"
    project_dir=$(cd "$project_dir" 2>/dev/null && pwd || echo "$project_dir")
    
    if [ ! -d "$project_dir" ]; then
        print_error "Directory does not exist: $project_dir"
        exit 1
    fi
    
    export PROJECT_DIR="$project_dir"
    
    # If no servers specified and not --all, show interactive menu
    if [ ${#servers_to_install[@]} -eq 0 ] && [ "$install_all" = false ]; then
        if [ "$NON_INTERACTIVE" = true ]; then
            # Non-interactive mode defaults to all
            install_all=true
        else
            # Interactive server selection
            echo "Select servers to install for your project type:"
            echo ""
            echo "  1) Frontend project (excludes: database)"
            echo "  2) Backend/API project (excludes: browser, playwright)"
            echo "  3) Full-stack project (all servers)"
            echo "  4) Custom selection"
            echo "  5) Install all servers"
            echo ""
            read -p "Enter your choice (1-5): " choice
            
            case $choice in
                1)
                    install_all=true
                    servers_to_exclude+=("database")
                    print_info "Using Frontend profile"
                    ;;
                2)
                    install_all=true
                    servers_to_exclude+=("browser" "playwright")
                    print_info "Using Backend/API profile"
                    ;;
                3)
                    install_all=true
                    print_info "Using Full-stack profile"
                    ;;
                4)
                    # Custom selection
                    echo ""
                    echo "Available servers:"
                    local all_keys=$(get_all_server_keys)
                    local i=1
                    for key in $all_keys; do
                        echo "  $i) $key - $(get_server_name "$key")"
                        ((i++))
                    done
                    echo ""
                    echo "Enter server numbers to install (space-separated, e.g., '1 3 5'):"
                    read -p "> " selections
                    
                    # Convert selections to server keys
                    local key_array=($all_keys)
                    for num in $selections; do
                        if [[ $num =~ ^[0-9]+$ ]] && [ $num -ge 1 ] && [ $num -le ${#key_array[@]} ]; then
                            servers_to_install+=("${key_array[$((num-1))]}")
                        fi
                    done
                    
                    if [ ${#servers_to_install[@]} -eq 0 ]; then
                        print_error "No valid servers selected"
                        exit 1
                    fi
                    ;;
                5)
                    install_all=true
                    print_info "Installing all servers"
                    ;;
                *)
                    print_error "Invalid choice"
                    exit 1
                    ;;
            esac
            echo ""
        fi
    fi
    
    # Determine which servers to install (if using --all or profiles)
    if [ "$install_all" = true ] && [ ${#servers_to_install[@]} -eq 0 ]; then
        servers_to_install=($(get_all_server_keys))
    fi
    
    # Filter out excluded servers
    if [ ${#servers_to_exclude[@]} -gt 0 ]; then
        local filtered=()
        for server in "${servers_to_install[@]}"; do
            local excluded=false
            for exclude in "${servers_to_exclude[@]}"; do
                if [ "$server" = "$exclude" ]; then
                    excluded=true
                    break
                fi
            done
            if [ "$excluded" = false ]; then
                filtered+=("$server")
            fi
        done
        servers_to_install=("${filtered[@]}")
    fi
    
    print_info "MCP Server Setup for project: $project_dir"
    echo ""
    
    # Show what will be installed
    if [ ${#servers_to_exclude[@]} -gt 0 ]; then
        print_status "Excluding servers: ${servers_to_exclude[*]}"
    fi
    print_status "Installing servers: ${servers_to_install[*]}"
    echo ""
    
    check_environment
    echo ""
    check_requirements
    echo ""
    
    # Install servers
    local failed=()
    local installed=()
    
    for server in "${servers_to_install[@]}"; do
        if install_server "$server"; then
            installed+=("$server")
        else
            failed+=("$server")
        fi
    done
    
    echo ""
    if [ ${#failed[@]} -eq 0 ]; then
        print_status "Installation completed successfully! ðŸŽ‰"
        echo ""
        echo "Project: $project_dir"
        echo "MCP configuration saved to: ~/.claude.json"
        echo ""
        
        # Check if Serena was installed
        for server in "${installed[@]}"; do
            if [ "$server" = "serena" ]; then
                echo "Next steps for Serena in Claude Code:"
                echo "  1. First run: 'Read initial instructions'"
                if [ -n "$SERENA_CHOSEN_NAME" ]; then
                    echo "  2. Then run: 'Activate the project $SERENA_CHOSEN_NAME'"
                    if [ "$SERENA_CHOSEN_NAME" != "$(basename "$project_dir")" ]; then
                        echo "  3. After first connection, edit .serena/project.yml to set project_name: $SERENA_CHOSEN_NAME"
                    fi
                else
                    echo "  2. Then run: 'Activate the project [your-project-name]'"
                fi
                echo ""
                break
            fi
        done
        
        echo "Installed servers: ${installed[*]}"
    else
        print_warning "Some servers failed to install: ${failed[*]}"
        if [ ${#installed[@]} -gt 0 ]; then
            echo "Successfully installed: ${installed[*]}"
        fi
    fi
}

# Uninstall command handler
handle_uninstall() {
    shift # Remove 'uninstall' from arguments
    local servers_to_uninstall=()
    local uninstall_all=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --all)
                uninstall_all=true
                shift
                ;;
            -*)
                print_error "Unknown option: $1"
                exit 1
                ;;
            *)
                servers_to_uninstall+=("$1")
                shift
                ;;
        esac
    done
    
    # Determine which servers to uninstall
    if [ "$uninstall_all" = true ]; then
        servers_to_uninstall=($(get_all_server_keys))
    elif [ ${#servers_to_uninstall[@]} -eq 0 ]; then
        print_error "No servers specified. Use server names or --all"
        echo "Available servers: $(get_all_server_keys)"
        exit 1
    fi
    
    # Uninstall servers
    local failed=()
    local uninstalled=()
    
    for server in "${servers_to_uninstall[@]}"; do
        if uninstall_server "$server"; then
            uninstalled+=("$server")
        else
            failed+=("$server")
        fi
    done
    
    echo ""
    if [ ${#failed[@]} -eq 0 ]; then
        print_status "Uninstallation completed successfully!"
        echo "Uninstalled servers: ${uninstalled[*]}"
    else
        print_warning "Some servers failed to uninstall: ${failed[*]}"
        if [ ${#uninstalled[@]} -gt 0 ]; then
            echo "Successfully uninstalled: ${uninstalled[*]}"
        fi
    fi
}

# Function to show server status
show_status() {
    print_status "Checking MCP server status..."
    
    if command -v claude &> /dev/null; then
        claude mcp list
        echo ""
        echo "MCP configuration file: ~/.claude.json"
    else
        print_error "Claude CLI not found. Cannot check server status."
    fi
}

# Function to show help
show_help() {
    echo "MCP Server Setup Script for Claude Code"
    echo ""
    echo "Usage: $(basename "$0") <command> [options] [arguments]"
    echo ""
    echo "Commands:"
    echo "  install [servers...] [dir]   Install MCP servers (defaults to all servers)"
    echo "  uninstall <servers...>       Uninstall MCP servers"
    echo "  status                       Show current MCP server status"
    echo "  help                         Show this help message"
    echo ""
    echo "Install examples:"
    echo "  $(basename "$0") install                   # Install all servers for current directory"
    echo "  $(basename "$0") install --all             # Explicitly install all servers"
    echo "  $(basename "$0") install serena            # Install only serena"
    echo "  $(basename "$0") install serena zen        # Install multiple servers"
    echo "  $(basename "$0") install ~/Projects/app    # Install all servers for specific directory"
    echo "  $(basename "$0") install serena ~/Projects/app  # Install serena for specific directory"
    echo ""
    echo "Install options:"
    echo "  --exclude <servers>                        # Exclude servers (comma-separated)"
    echo "  --profile <type>                           # Use predefined profile (frontend, backend, api, fullstack)"
    echo "  --non-interactive, -n                      # Don't prompt for input"
    echo "  --serena-project-name <name>               # Set Serena project name (for non-interactive mode)"
    echo "  --database-urls <urls>                     # Database URLs separated by semicolons (for non-interactive mode)"
    echo ""
    echo "Profile examples:"
    echo "  $(basename "$0") install --profile frontend   # All servers except database"
    echo "  $(basename "$0") install --profile backend    # All servers except browser/playwright"
    echo "  $(basename "$0") install --profile api        # All servers except browser/playwright"
    echo "  $(basename "$0") install --profile fullstack  # All servers"
    echo ""
    echo "Exclude examples:"
    echo "  $(basename "$0") install --exclude database                  # Install all except database"
    echo "  $(basename "$0") install --exclude database,browser         # Exclude multiple servers"
    echo "  $(basename "$0") install serena zen --exclude database      # Only works with --all"
    echo ""
    echo "Non-interactive examples:"
    echo "  $(basename "$0") install --non-interactive --serena-project-name myapp-frontend"
    echo "  $(basename "$0") install database -n --database-urls 'postgres://user:pass@localhost:5432/db1;postgres://user:pass@localhost:5432/db2'"
    echo ""
    echo "Database URL formats:"
    echo "  postgres://username:password@host:port/database_name"
    echo "  mysql://username:password@host:port/database_name"
    echo ""
    echo "Uninstall examples:"
    echo "  $(basename "$0") uninstall serena          # Uninstall serena"
    echo "  $(basename "$0") uninstall serena zen      # Uninstall multiple servers"
    echo "  $(basename "$0") uninstall --all           # Uninstall all servers"
    echo ""
    echo "Available servers:"
    local all_keys=$(get_all_server_keys)
    for key in $all_keys; do
        echo "  â€¢ $key - $(get_server_name "$key")"
    done
    echo ""
    echo "Required environment variables:"
    echo "  â€¢ OPENAI_API_KEY"
    echo "  â€¢ ANTHROPIC_API_KEY"
    echo "  â€¢ GOOGLE_CLOUD_PROJECT"
    echo "  â€¢ TAVILY_API_KEY"
}

# Main script logic
main() {
    local command=${1:-help}
    
    case $command in
        install)
            handle_install "$@"
            ;;
        uninstall)
            handle_uninstall "$@"
            ;;
        status)
            show_status
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            print_error "Unknown command: $command"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Run main function
main "$@"